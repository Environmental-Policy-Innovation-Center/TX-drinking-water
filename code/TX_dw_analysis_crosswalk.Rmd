---
title: "TX Drinking Water Data Analysis - Crosswalk"
author: "EmmaLi Tsai"
date: "2024-04-01"
last_updated: "2024-04-04"
output: html_document
---

## Loading Packages & Data
```{r}
# loading packages: 
library(aws.s3)
library(tidyverse)
library(leaflet)
library(sf)
library(areal)
library(tidycensus)
library(corrplot)
library(crsuggest)
library(tigris)
options(tigris_use_cache = TRUE)

# loading lists of data 
demo <- aws.s3::s3read_using(readRDS, 
                             object = "s3://tech-team-data/state-drinking-water/TX/clean/TX_demographic_list.RData")
keys <- aws.s3::s3read_using(readRDS, 
                             object = "s3://tech-team-data/state-drinking-water/TX/clean/TX_merging_keys_list.RData")
bg_crosswalk <- aws.s3::s3read_using(read.csv, 
                                     object = "s3://tech-team-data/pws_crosswalk/pws_census_blockgroup_weighted_crosswalk.csv") %>%
                                     select(-X)
```

## TX-wide comparisons: 
```{r}
################################################################################
# quick map to see where we're at: 
################################################################################
leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = demo$census,
              opacity = 0.9,
              color = "gray",
              weight = 1,
              label = paste0("pwsid: ", 
                             demo$census$pwsid))

################################################################################
# Comparing all methods: 
################################################################################
# figuring out differences in population estimates: 
census <- demo$census %>% 
  # filtering all pwsids where the crosswalk was incomplete - so we have fully
  # comparable pwsids: 
  filter(!is.na(estimate_total_pop))
# removing ones that cross borders with Arkansas: 
census <- census[str_detect(census$pwsid, "TX"),] 
crosswalk <- census$estimate_total_pop
sdwis <- census$population_served_count

# census tracts for areal interpolation: 
tract_geo <- tidycensus::get_acs(
  geography = "tract", 
  variables = "B01003_001", 
  state = c("TX"),
  year = 2020,
  geometry = TRUE
)

# matching crs & interpolating: 
tract_geo <- tract_geo %>%
  st_transform(., crs = "ESRI:102296") %>%
  select(GEOID, estimate)

census_sf <- census %>%
  st_transform(., crs = "ESRI:102296") %>%  
  filter(!st_is_empty(.))%>%
  select(pwsid, geometry)

interpolate <- areal::aw_interpolate(census_sf, tid="pwsid", 
                                     source=tract_geo, 
                                     sid="GEOID", 
                                     # weight = "sum",
                                     weight = "total",
                                     output="sf", 
                                     extensive="estimate")

# comparing all estimates so far: 
pop_comp <- census %>%
  as.data.frame() %>%
  select(pwsid, population_served_count, estimate_total_pop) %>%
  left_join(interpolate) %>%
  as.data.frame() %>%
  select(-geometry) %>%
  rename(SDWIS = population_served_count, 
         crosswalk = estimate_total_pop, 
         areal_interp = estimate)

# pivoting to long to make plotting multiple estimates easier: 
pop_comp_long <- pivot_longer(pop_comp, crosswalk:areal_interp)
ggplot(pop_comp_long, aes(x = SDWIS, y = value, color = name)) + 
  geom_point(alpha = 0.5) + 
  geom_line(aes(x = SDWIS, y = SDWIS), color = "black", lty = "dashed") +
  xlim(0,500000) + 
  ylim(0,500000) + 
  theme_minimal()

################################################################################
# Plots & maps for comparison: 
################################################################################
pop_comp_sf <- census %>%
  as.data.frame() %>%
  select(pwsid, population_served_count, estimate_total_pop) %>%
  left_join(interpolate) %>%
  rename(sdwis = population_served_count, 
         crosswalk = estimate_total_pop, 
         areal_interp = estimate) %>%
  mutate(sdwis_crosswalk_diff = abs(sdwis - crosswalk), 
         sdwis_areal_diff = abs(sdwis - areal_interp), 
         sdwis_crosswalk_percent_diff = ((sdwis - crosswalk)/((sdwis + crosswalk)/2))*100, 
         sdwis_interp_percent_diff = ((sdwis - areal_interp)/((sdwis + areal_interp)/2))*100, 
         # what if we took the mean of the two methods?
         test_mean = (sdwis + areal_interp)/2, 
         test_percent_diff  = ((sdwis - test_mean)/((sdwis + test_mean)/2))*100) %>%
  st_as_sf(.) %>%
  st_transform(., crs = st_crs(census))

# plotting these as point graphs: 
ggplot(pop_comp_sf, aes(x = sdwis_crosswalk_diff, y = sdwis)) + 
  geom_point(alpha = 0.5) +
  geom_point(aes(x = sdwis_areal_diff), color = "red", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "abs(sdwis - estimate)", y = "SDWIS pop") 

ggplot(pop_comp_sf, aes(x = sdwis_crosswalk_percent_diff, y = sdwis)) + 
  geom_point(alpha = 0.5) +
  geom_point(aes(x = sdwis_interp_percent_diff), color = "red", alpha = 0.5) + 
  geom_point(aes(x = test_percent_diff), color = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "% Difference", y = "SDWIS pop") 
# % difference for the crosswalk is generally negative, indicating that the 
# crosswalk consistently overestimates populations (which we know)
# areal interpolation and SDWIS are close (i.e., % difference is 0) at high
# SDWIS populations. 

#  plotting percent difference: 
ggplot(pop_comp_sf, aes(x = sdwis_crosswalk_percent_diff, 
                        y = sdwis_interp_percent_diff, 
                        color = sdwis)) + 
  geom_point() +
  theme_minimal() + 
  labs(x = "% Diff Crosswalk", y = "% Diff Interpolation") + 
  geom_abline(intercept = 0, slope = 1, lty = "dashed",
              size = 1, color = "red") + 
  geom_hline(yintercept = 0, color = "darkred") + 
  geom_vline(xintercept = 0, color = "darkred")
# this plot just confirms that areal interpolation has smaller % difference 
# than crosswalk. 

# ggplot(pop_comp_sf, aes(x = sdwis_crosswalk_diff, 
#                         y = sdwis_areal_diff, 
#                         color = sdwis)) + 
#   geom_point() +
#   theme_minimal() + 
#   labs(x = "% Diff Crosswalk", y = "% Diff Interpolation") + 
#   geom_abline(intercept = 0, slope = 1, lty = "dashed",
#               size = 1, color = "red") + 
#   geom_hline(yintercept = 0, color = "darkred") + 
#   geom_vline(xintercept = 0, color = "darkred")


# can I bin these into different population categories? 
pop_comp_sf$pop_bin <- cut(pop_comp_sf$sdwis, breaks = c(0, 20, 50, 100, 
                                                         250, 400, 
                                                         500, 750, 
                                                         1000, 1500, 2500, 5000, 
                                                         10000, 30000, 
                                                         50000, 2205000))
ggplot(pop_comp_sf, aes(x = sdwis_crosswalk_percent_diff, 
                        y = sdwis_interp_percent_diff)) + 
  geom_point() +
  theme_minimal() + 
  labs(x = "% Diff Crosswalk", y = "% Diff Interpolation") + 
  geom_abline(intercept = 0, slope = 1, lty = "dashed",
              size = 1, color = "red") + 
  geom_hline(yintercept = 0, color = "darkred") + 
  geom_vline(xintercept = 0, color = "darkred") + 
  facet_wrap(~pop_bin)+ 
  ggtitle("Comparison of Methods by Population")
# interesting! definitely appears to be a clear trend where as SDWIS population
# increases, the % diff for each method converges to 0%, BUT this might just be
# because when you calculate % difference you're taking the mean of SDWIS and 
# the population estimate, which means you're just dividing by a larger number 
# for larger populations...


# what about by area? 
pop_comp_area <- census %>%
  select(pwsid, area_miles) %>%
  as.data.frame() %>%
  select(-geometry)
pop_comp_area <- merge(pop_comp_sf, pop_comp_area, by = "pwsid")
pop_comp_area$area_bin <- cut(pop_comp_area$area_miles, breaks = c(0, 0.01, 
                                                                   0.02, 0.05,  0.1, 0.25, 
                                                                   0.5, 1, 
                                                                   2, 3, 5, 10, 
                                                                   15, 20, 50, 80, 150))
ggplot(pop_comp_area, aes(x = sdwis_crosswalk_percent_diff, 
                        y = sdwis_interp_percent_diff)) + 
  geom_point() +
  theme_minimal() + 
  labs(x = "% Diff Crosswalk", y = "% Diff Interpolation") + 
  geom_abline(intercept = 0, slope = 1, lty = "dashed",
              size = 1, color = "red") + 
  geom_hline(yintercept = 0, color = "darkred") + 
  geom_vline(xintercept = 0, color = "darkred") + 
  facet_wrap(~area_bin)+ 
  ggtitle("Comparison of Methods by Utility Area")
# generally same trend as population - larger the area = more similar the
# population estimate is to SDWIS


# what about population density? 
pop_comp_den <- census %>%
  select(pwsid, pop_density) %>%
  as.data.frame() %>%
  select(-geometry)
pop_comp_den <- merge(pop_comp_sf, pop_comp_den, by = "pwsid")
pop_comp_den$pop_den_bin <- cut(pop_comp_den$pop_density, breaks = c(0, 100, 
                                                                     500, 1000, 
                                                                     5000,
                                                                     10000, 
                                                                     25000,
                                                                     50000, 
                                                                     75000, 
                                                                     100000, 
                                                                     1000000))
ggplot(pop_comp_den, aes(x = sdwis_crosswalk_percent_diff, 
                          y = sdwis_interp_percent_diff)) + 
  geom_point() +
  theme_minimal() + 
  labs(x = "% Diff Crosswalk", y = "% Diff Interpolation") + 
  geom_abline(intercept = 0, slope = 1, lty = "dashed",
              size = 1, color = "red") + 
  geom_hline(yintercept = 0, color = "darkred") + 
  geom_vline(xintercept = 0, color = "darkred") + 
  facet_wrap(~pop_den_bin) + 
  ggtitle("Comparison of Methods by Population Density")
# okay trends with population density are odd - appears that pop density might 
# have a strong impact on areal interpolation 


# mapping: 
diff_pal <- colorNumeric(
  palette = RColorBrewer::brewer.pal(11, "BrBG"),
  domain = pop_comp_sf$sdwis_interp_percent_diff)
leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = pop_comp_sf,
              opacity = 0.9,
              color = ~diff_pal(sdwis_interp_percent_diff),
              weight = 1,
              label = paste0("% diff: ", 
                             round(pop_comp_sf$sdwis_interp_percent_diff, 2))) %>%
  addLegend("bottomright",
            pal = diff_pal,
            values = pop_comp_sf$sdwis_interp_percent_diff,
            title = "% difference",
            opacity = 1)
# negative = method > SDIWS; 
# positive = SDWIS > method 

# correlations: 
interesting_vars <- census %>%
  select(pwsid, service_connections_count, area_miles, pop_density) %>%
  as.data.frame() %>%
  select(-geometry)
vars_comp <- pop_comp_sf %>%
  left_join(interesting_vars) %>%
  as.data.frame() %>%
  select(-geometry) %>%
  mutate(abs_sdwis_crosswalk_percent_diff = abs(sdwis_crosswalk_percent_diff), 
         abs_sdwis_interp_percent_diff = abs(sdwis_interp_percent_diff))

all_cor <- cor(vars_comp %>% 
                 select(c(sdwis, crosswalk, areal_interp, 
                          service_connections_count, area_miles, pop_density, 
                          abs_sdwis_crosswalk_percent_diff, 
                          abs_sdwis_interp_percent_diff)), 
               use = "pairwise.complete.obs")

cor_pvals <- cor.mtest(all_cor, conf.level = 0.95)
cor_pvals$p

corrplot(all_cor, method = 'ellipse', type = 'upper', 
         p.mat = cor_pvals$p, insig = "p-value", sig.level = -1)

################################################################################
# Comparing the total population estimates: 
################################################################################
sum(pop_comp_sf$sdwis, na.rm = T) 
sum(pop_comp_sf$crosswalk, na.rm = T) 
sum(pop_comp_sf$areal_interp, na.rm = T) 
# 24,506,613 when using total weights (which makes more sense:)

# mean values: 
mean(abs(pop_comp_sf$sdwis_crosswalk_percent_diff), na.rm = T)
mean(abs(pop_comp_sf$sdwis_interp_percent_diff), na.rm = T)
median(abs(pop_comp_sf$sdwis_crosswalk_percent_diff), na.rm = T)
median(abs(pop_comp_sf$sdwis_interp_percent_diff), na.rm = T)

# plots to visualize distribution 
ggplot(pop_comp_sf, aes(x = sdwis_crosswalk_percent_diff)) + 
  geom_histogram() + 
  geom_histogram(aes(x = sdwis_interp_percent_diff), 
                 fill = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "% Difference from SDWIS")

ggplot(pop_comp_sf, aes(x = sdwis_crosswalk_diff)) + 
  geom_histogram() + 
  geom_histogram(aes(x = sdwis_areal_diff), 
                 fill = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "Absolute Difference from SDWIS")

# Texas population: 28,635,442
tidycensus::get_acs(
  geography = "state", 
  variables = "B01003_001", 
  state = c("TX"),
  year = 2020,
  geometry = TRUE
)


# what about just straight difference?
pop_comp_sf <- pop_comp_sf %>%
  mutate(sdwis_interp_diff = abs(sdwis - areal_interp), 
         sdwis_cross_diff = abs(sdwis - crosswalk))
mean(pop_comp_sf$sdwis_interp_diff)
mean(pop_comp_sf$sdwis_cross_diff)

## summary so far: areal interpolation is closer to census population. SDWIS 
# is still larger than the census population by ~500,000. The crosswalk 
# population is nearly double that of the census population and appears to 
# consistently overestimate across the board. 
```

## East TX comparisons: 
```{r}
# grabbing East TX census population: 
etx_census <- tidycensus::get_acs(
  geography = "county", 
  variables = "B01003_001", 
  state = c("TX"), 
  year = 2020, 
  geometry = TRUE
)
# filtering census data for the right counties: 
counties <- unlist(strsplit(etx_census$NAME, split = ","))
etx_census$counties <- trimws(counties[grepl("County", counties)])

east_tx <- read.csv("./data/raw/east_TX_counties.csv") %>%
  select(-X) %>%
  mutate(county_tidy = paste0(county_name, " County"))

east_tx_geo <- etx_census %>%
  filter(counties %in% east_tx$county_tidy) 

sum(east_tx_geo$estimate) # 1,928,057

################################################################################
# Comparing total population estimates: 
################################################################################
east_tx_pwsids <- demo$census %>%
  filter(east_tx_flag == "yes")
# mean values: 
etx_comp_sf <- pop_comp_sf %>%
  filter(pwsid %in% east_tx_pwsids$pwsid) 
mean(etx_comp_sf$sdwis_crosswalk_percent_diff, na.rm = T)
mean(etx_comp_sf$sdwis_interp_percent_diff, na.rm = T)

sum(etx_comp_sf$sdwis)
sum(etx_comp_sf$crosswalk)
sum(etx_comp_sf$areal_interp)

# what about just straight difference?
etx_comp_sf <- etx_comp_sf %>%
  mutate(sdwis_interp_diff = abs(sdwis - areal_interp), 
         sdwis_cross_diff = abs(sdwis - crosswalk))
mean(etx_comp_sf$sdwis_interp_diff)
mean(etx_comp_sf$sdwis_cross_diff)

# plots for viz: 
ggplot(etx_comp_sf, aes(x = sdwis_crosswalk_percent_diff)) + 
  geom_histogram() + 
  geom_histogram(aes(x = sdwis_interp_percent_diff), 
                 fill = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "% Difference from SDWIS")

ggplot(etx_comp_sf, aes(x = sdwis_cross_diff)) + 
  geom_histogram() + 
  geom_histogram(aes(x = sdwis_interp_diff), 
                 fill = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "Absolute Difference from SDWIS")
```

## Well data from EPA-ORD 
```{r}
# downloaded using the webmap viewer on 3/20/2024
wells <- aws.s3::s3read_using(read.csv, 
                     object = "s3://tech-team-data/state-drinking-water/TX/raw/TX_bg_wellpop_EPAORD.csv") %>%
  janitor::clean_names()

well_pop <- wells %>%
  select(geoid, x2020_population, population_served_by_wells_2020) %>%
  mutate(x2020_population = readr::parse_number(x2020_population), 
         population_served_by_wells_2020 = readr::parse_number(population_served_by_wells_2020)) %>%
  mutate(population_not_wells = x2020_population - population_served_by_wells_2020, 
         percent_cws = (population_not_wells/x2020_population)*100)

# grabbing census geographies to map this - using decennial census because 
# that's what EPA's well data is based off of: 
# vars <- load_variables(2020, "pl")
bg_census <- tidycensus::get_decennial(
  geography = "block group",
  variables = "P1_001N",
  state = "TX",
  year = 2020, 
  geometry = TRUE
)
sum(bg_census$value) 
# 29,145,505 - population reported from 2020 Decennial census 

# mapping:
well_census <- merge(well_pop, bg_census, by.x = "geoid", by.y = "GEOID", 
                     all.x = TRUE) %>%
  st_as_sf()
well_pal <- colorNumeric(
  palette = viridis::mako(9),
  domain = well_census$percent_cws)
leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = well_census,
              opacity = 0.9,
              color = ~well_pal(percent_cws),
              weight = 1,
              label = paste0("% CWS: ", round(well_census$percent_cws, 2))) %>%
  addLegend("bottomright",
            pal = well_pal,
            values = well_census$percent_cws,
            title = "% CWS",
            opacity = 1)

## grabbing some summary stats here: 
sum(well_census$x2020_population) # 7,401,970
sum(well_census$population_served_by_wells_2020) # 2,493,742
sum(well_census$population_not_wells) # 4,908,228

# population in TX (which excludes major cities, which are likely on CWS: 7,401,970)
# population on wells (which excludes major cities): 2,493,742

# so TX population on CWS (assuming population of 29,530,000): 
# 29530000-2493742 = 27036258
# 27,036,258, or 91.56% of the population in TX

# % population on wells (assuming population of 29,530,000): 
# 100 - 91.56 = 8.44% 

## What about East TX?
# filtering census data for the right counties: 
counties <- unlist(strsplit(well_census$NAME, split = ","))
well_census$counties <- trimws(counties[grepl("County", counties)])

east_tx <- read.csv("./data/raw/east_TX_counties.csv") %>%
  select(-X) %>%
  mutate(county_tidy = paste0(county_name, " County"))

well_census_etx <- well_census %>%
  filter(counties %in% east_tx$county_tidy) 

sum(well_census_etx$population_served_by_wells_2020) # 420,974
```

## Jefferson Co - no overlapping SABs: 
```{r}
################################################################################ 
# Small test case in Jefferson county, where SABs don't overlap 
################################################################################ 
jeff_co <- etx_census %>% filter(NAME == "Jefferson County, Texas")
# population: 253,136
jeff_sabs <- census %>% filter(county_served == "JEFFERSON")
sum(jeff_sabs$population_served_count)
# sdwis population: 236,970
sum(jeff_sabs$estimate_total_pop)
# crosswalk: 308,588.5

# okay let's try areal interpolation first: 
# grabbing tract geometries in Jefferson Co: 
census_tract <- tidycensus::get_acs(
  geography = "tract", 
  variables = "B01003_001", 
  state = c("TX"), 
  year = 2020, 
  geometry = TRUE
)
jeff_co_tracts <- census_tract[str_detect(census_tract$NAME, "Jefferson"),]

# what does this look like: 
pop_pal <- colorNumeric(
  palette = viridis::mako(9),
  domain = jeff_co_tracts$estimate)
leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = jeff_sabs,
              opacity = 0.7,
              color = "black",
              weight = 1.9,
              label = paste0("pwsid:", jeff_sabs$pwsid)) %>%
  addPolygons(data = jeff_co_tracts,
              opacity = 0.7,
              color = "grey", 
              # color = ~pop_pal(estimate),
              weight = 1,
              label = jeff_co_tracts$estimate)


# transforming before aw interpolate: 
jeff_sabs <- jeff_sabs %>%
  st_as_sf() %>%
  st_transform(., crs = 26915)
jeff_co_tracts <- jeff_co_tracts %>%
  st_as_sf() %>%
  st_transform(., crs = 26915)

interpolate <- areal::aw_interpolate(jeff_sabs, 
                                     tid="pwsid",
                                     source=jeff_co_tracts, 
                                     sid="GEOID", 
                                     # weight = "sum",
                                     weight = "total",
                                     output="sf", 
                                     extensive="estimate")

# what did the interpolation estimate: 
sum(interpolate$estimate)
# extensive: 253,136 - which makes sense because every individual is 
# added to a pwsid 
# extensive with total weight: 227,000.1


################################################################################ 
# Plots and maps for comparison: 
################################################################################ 
method_comp <- interpolate %>%
  select(pwsid, population_served_count, estimate_total_pop, estimate) %>%
  rename(sdwis = population_served_count, 
         crosswalk = estimate_total_pop, 
         areal_interp = estimate)

ggplot(method_comp, aes(x = sdwis, y = crosswalk)) + 
  geom_point(color = "blue") + 
  geom_line(color = "blue") + 
  geom_point(aes(y = areal_interp), color = "darkred") + 
  geom_line(aes(y = areal_interp), color = "darkred") + 
  geom_line(aes(y = sdwis), color = "black") + 
  geom_point(aes(y = sdwis), color = "black") + 
  theme_minimal() + 
  labs(x = "SDWIS", y = "Estimate")
# wow areal interpolation is a lot closer

# what about the % difference? 
jco_comp_sf <- method_comp %>%
  mutate(sdwis_crosswalk_percent_diff = ((sdwis - crosswalk)/((sdwis + crosswalk)/2))*100, 
         sdwis_interp_percent_diff = ((sdwis - areal_interp)/((sdwis + areal_interp)/2))*100) %>%
  st_as_sf(.) %>%
  st_transform(., crs = st_crs(census))

# plotting these as point graphs: 
ggplot(jco_comp_sf, aes(x = sdwis_crosswalk_percent_diff, y = sdwis)) + 
  geom_point(color = "blue") +
  geom_point(aes(x = sdwis_interp_percent_diff), color = "red") + 
  theme_minimal() + 
  labs(x = "% Difference", y = "SDWIS pop") 

# plotting percent difference: 
ggplot(jco_comp_sf, aes(x = sdwis_crosswalk_percent_diff, 
                        y = sdwis_interp_percent_diff, 
                        color = sdwis)) + 
  geom_point() +
  theme_minimal() + 
  labs(x = "% Diff Crosswalk", y = "% Diff Interpolation") + 
  geom_abline(intercept = 0, slope = 1, lty = "dashed",
              size = 1, color = "red") + 
  geom_hline(yintercept = 0, color = "darkred") + 
  geom_vline(xintercept = 0, color = "darkred")

# mapping: 
diff_pal <- colorBin(
  palette = RColorBrewer::brewer.pal(11, "BrBG"),
  bins = c(-200, -100, -50, 0, 50, 100, 200))
leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = jco_comp_sf,
              opacity = 0.9,
              color = "grey",
              weight = 1) %>%
  addPolygons(data = jco_comp_sf,
              opacity = 0.9,
              color = ~diff_pal(sdwis_crosswalk_percent_diff),
              weight = 1,
              label = paste0("% diff: ", 
                             round(jco_comp_sf$sdwis_crosswalk_percent_diff, 2))) %>%
  addLegend("bottomright",
            pal = diff_pal,
            values = jco_comp_sf$sdwis_crosswalk_percent_diff,
            title = "% difference",
            opacity = 1)

## investigating correlation between methods and other vars of interest: 
vars_comp <- jco_comp_sf %>%
  left_join(interesting_vars) %>%
  as.data.frame() %>%
  select(-geometry) %>%
  mutate(abs_sdwis_crosswalk_percent_diff = abs(sdwis_crosswalk_percent_diff), 
         abs_sdwis_interp_percent_diff = abs(sdwis_interp_percent_diff))

all_cor <- cor(vars_comp %>% 
                 select(c(sdwis, crosswalk, areal_interp, 
                          service_connections_count, area_miles, pop_density, 
                          abs_sdwis_crosswalk_percent_diff, 
                          abs_sdwis_interp_percent_diff)), 
               use = "pairwise.complete.obs")

cor_pvals <- cor.mtest(all_cor, conf.level = 0.95)
cor_pvals$p

corrplot(all_cor, method = 'ellipse', type = 'upper', 
         p.mat = cor_pvals$p, insig = "p-value", sig.level = -1)

################################################################################ 
# Comparing total population estimates: 
################################################################################ 
sum(jco_comp_sf$sdwis)
sum(jco_comp_sf$crosswalk)
sum(jco_comp_sf$areal_interp)

# checking out how this compares to EPA's ORD:
jeff_co_well <- well_census[str_detect(well_census$NAME, "Jefferson County"),]
sum(jeff_co_well$population_served_by_wells_2020)
# 10,894 people served by domestic wells in Jefferson County, 
# so our target cws pop should be 242,242

mean(jco_comp_sf$sdwis_crosswalk_percent_diff)
median(jco_comp_sf$sdwis_crosswalk_percent_diff)
mean(jco_comp_sf$sdwis_interp_percent_diff)
median(jco_comp_sf$sdwis_interp_percent_diff)

# what if we just took the mean of the two methods?
method_comp$mean_cross_interp <- (method_comp$crosswalk + 
                                    method_comp$areal_interp)/2

# what about just straight difference?
jco_comp_sf <- jco_comp_sf %>%
  mutate(sdwis_interp_diff = abs(sdwis - areal_interp), 
         sdwis_cross_diff = abs(sdwis - crosswalk))
mean(jco_comp_sf$sdwis_interp_diff)
mean(jco_comp_sf$sdwis_cross_diff)

# what about wells: 
jefferson_wells <- well_census[str_detect(well_census$NAME, "Jefferson"),]
sum(jefferson_wells$population_served_by_wells_2020)

# visualizing distributions: 
ggplot(jco_comp_sf, aes(x = sdwis_crosswalk_percent_diff)) + 
  geom_histogram() + 
  geom_histogram(aes(x = sdwis_interp_percent_diff), 
                 fill = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "% Difference from SDWIS")

ggplot(jco_comp_sf, aes(x = sdwis_cross_diff)) + 
  geom_histogram() + 
  geom_histogram(aes(x = sdwis_interp_diff), 
                 fill = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "Absolute Difference from SDWIS")
```

## Harris Co - overlapping SABs
```{r}
# grabbing tract geometries: 
tract_geo <- tidycensus::get_acs(
  geography = "tract", 
  variables = "B01003_001", 
  state = c("TX"),
  year = 2020,
  geometry = TRUE
)
# grabbing some other counties since the SABs bleed into these: 
harris_co <- tract_geo[str_detect(tract_geo$NAME, paste(c("Harris County, Texas", 
                                                          "Waller County, Texas", 
                                                          "Montgomery County, Texas", 
                                                          "Galveston County, Texas", 
                                                          "Chambers County, Texas", 
                                                          "Fort Bend County, Texas"), 
                                                        collapse ="|")),]
harris_sabs <- census %>% filter(county_served == "HARRIS") %>%
  filter(!(is.na(estimate_total_pop)))

sum(harris_co[str_detect(harris_co$NAME, "Harris"),]$estimate)
sum(harris_sabs$population_served_count)
sum(harris_sabs$estimate_total_pop, na.rm = T)

# what does this look like: 
leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = harris_sabs,
              opacity = 0.7,
              color = "black",
              weight = 1.9,
              label = paste0("pwsid:", harris_sabs$pwsid)) %>%
  addPolygons(data = harris_co,
              opacity = 0.7,
              color = "grey",
              weight = 1,
              label = harris_co$estimate)


# transforming before aw interpolate: 
harris_sabs <- harris_sabs %>%
  st_as_sf() %>%
  st_transform(., crs = 26915)
harris_co_tracts <- harris_co %>%
  st_as_sf() %>%
  st_transform(., crs = 26915)

harris_interpolate <- areal::aw_interpolate(harris_sabs, 
                                            tid="pwsid",
                                            source=harris_co_tracts, 
                                            sid="GEOID", 
                                            # weight = "sum", 
                                            weight = "total",
                                            output="sf", 
                                            extensive="estimate")

# what did the interpolation estimate: 
sum(harris_interpolate$estimate, na.rm = T)

################################################################################ 
# Plots and maps for comparison: 
################################################################################ 
harris_method_comp <- harris_interpolate %>%
  select(pwsid, population_served_count, estimate_total_pop, estimate) %>%
  rename(sdwis = population_served_count, 
         crosswalk = estimate_total_pop, 
         areal_interp = estimate)

ggplot(harris_method_comp, aes(x = sdwis, y = crosswalk)) + 
  geom_point(color = "blue") + 
  geom_line(color = "blue") + 
  geom_point(aes(y = areal_interp), color = "darkred") + 
  geom_line(aes(y = areal_interp), color = "darkred") + 
  geom_line(aes(y = sdwis), color = "black") + 
  geom_point(aes(y = sdwis), color = "black") + 
  theme_minimal() + 
  labs(x = "SDWIS", y = "Estimate")
# wow areal interpolation is a lot closer


  ## what does this look like spatially? 
harris_comp_sf <- harris_method_comp %>%
  mutate(sdwis_crosswalk_percent_diff = ((sdwis - crosswalk)/((sdwis + crosswalk)/2))*100, 
         sdwis_interp_percent_diff = ((sdwis - areal_interp)/((sdwis + areal_interp)/2))*100) %>%
  st_as_sf(.) %>%
  st_transform(., crs = st_crs(census))

# plotting these as point graphs: 
ggplot(harris_comp_sf, aes(x = sdwis_crosswalk_percent_diff, y = sdwis)) + 
  geom_point(color = "blue", alpha = 0.5) +
  geom_point(aes(x = sdwis_interp_percent_diff), color = "red", 
             alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "% Difference", y = "SDWIS pop") 

# plotting percent difference: 
ggplot(harris_comp_sf, aes(x = sdwis_crosswalk_percent_diff, 
                        y = sdwis_interp_percent_diff, 
                        color = sdwis)) + 
  geom_point() +
  theme_minimal() + 
  labs(x = "% Diff Crosswalk", y = "% Diff Interpolation") + 
  geom_abline(intercept = 0, slope = 1, lty = "dashed",
              size = 1, color = "red") + 
  geom_hline(yintercept = 0, color = "darkred") + 
  geom_vline(xintercept = 0, color = "darkred")

# mapping: 
diff_pal <- colorBin(
  palette = RColorBrewer::brewer.pal(11, "BrBG"),
  bins = c(-200, -100, -50, 0, 50, 100, 200))
leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = harris_comp_sf,
              opacity = 0.9,
              color = "grey",
              weight = 1) %>%
  addPolygons(data = harris_comp_sf,
              opacity = 0.9,
              color = ~diff_pal(sdwis_crosswalk_percent_diff),
              weight = 1,
              label = paste0("pwsid: ", harris_comp_sf$pwsid,
                             "; SDWIS: ", harris_comp_sf$sdwis,
                             "; cross estimate: ", round(harris_comp_sf$crosswalk, 2),
                             "; areal estimate: ", round(harris_comp_sf$areal_interp, 2),
                             "; % diff cross: ", 
                             round(harris_comp_sf$sdwis_crosswalk_percent_diff, 2), 
                             "; % diff areal: ", 
                             round(harris_comp_sf$sdwis_interp_percent_diff, 2))) %>%
  addLegend("bottomright",
            pal = diff_pal,
            values = harris_comp_sf$sdwis_crosswalk_percent_diff,
            title = "% difference",
            opacity = 1)

## investigating correlation between methods and other vars of interest: 
vars_comp <- harris_comp_sf %>%
  left_join(interesting_vars) %>%
  as.data.frame() %>%
  select(-geometry) %>%
  mutate(abs_sdwis_crosswalk_percent_diff = abs(sdwis_crosswalk_percent_diff), 
         abs_sdwis_interp_percent_diff = abs(sdwis_interp_percent_diff))

all_cor <- cor(vars_comp %>% 
                 select(c(sdwis, crosswalk, areal_interp, 
                          service_connections_count, area_miles, pop_density, 
                          abs_sdwis_crosswalk_percent_diff, 
                          abs_sdwis_interp_percent_diff)), 
               use = "pairwise.complete.obs")

cor_pvals <- cor.mtest(all_cor, conf.level = 0.95)
cor_pvals$p

corrplot(all_cor, method = 'ellipse', type = 'upper', 
         p.mat = cor_pvals$p, insig = "p-value", sig.level = -1)

################################################################################ 
# Comparing total population estimates: 
################################################################################ 
sum(harris_comp_sf$sdwis)
sum(harris_comp_sf$crosswalk)
sum(harris_comp_sf$areal_interp)

# grabbing mean % difference: 
mean(harris_comp_sf$sdwis_crosswalk_percent_diff, na.rm = T)
median(harris_comp_sf$sdwis_crosswalk_percent_diff, na.rm = T)
mean(harris_comp_sf$sdwis_interp_percent_diff, na.rm = T)
median(harris_comp_sf$sdwis_interp_percent_diff, na.rm = T)

# NOTE: census estimate is JUST harris co, but grabbed all other 
# counties to complete areal interpolation methods: 

# filtering well data 
well_census_hco <- well_census %>%
  filter(counties %in% c("Harris County")) 

sum(well_census_hco$population_served_by_wells_2020)

harris_comp_sf <- harris_comp_sf %>%
  mutate(sdwis_interp_diff = abs(sdwis - areal_interp), 
         sdwis_cross_diff = abs(sdwis - crosswalk))
mean(jco_comp_sf$sdwis_interp_diff)
mean(jco_comp_sf$sdwis_cross_diff)

ggplot(harris_comp_sf, aes(x = sdwis_crosswalk_percent_diff)) + 
  geom_histogram() + 
  geom_histogram(aes(x = sdwis_interp_percent_diff), 
                 fill = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "% Difference from SDWIS")

ggplot(harris_comp_sf, aes(x = sdwis_cross_diff)) + 
  geom_histogram() + 
  geom_histogram(aes(x = sdwis_interp_diff), 
                 fill = "blue", alpha = 0.5) + 
  theme_minimal() + 
  labs(x = "Absolute Difference from SDWIS")
```

## Investigating relationship with population density: 
```{r}
pop_den <- demo$census %>%
  select(pwsid, area_miles, pop_density) %>%
  as.data.frame() %>%
  select(-geometry)
pop_den_comparison <- pop_comp_sf %>%
  left_join(pop_den)
ggplot(pop_den_comparison, aes(x = sdwis_crosswalk_percent_diff, y = pop_density)) + 
  geom_point(color = "grey20", alpha = 0.4) +
  # geom_point(aes(x = sdwis_interp_percent_diff), color = "blue", alpha = 0.4) + 
  # geom_point(color = "blue", alpha = 0.4) + 
  geom_smooth(color = "black", fill = "grey") + 
  theme_minimal() + 
  labs(x = "% Difference", y = "Population Density")
```


## Testing method - a small test case: 
```{r}
###############################################################################
# Finding cutoff point for area: 
###############################################################################
ggplot(pop_den_comparison, 
       aes(x = area_miles, y = sdwis_interp_percent_diff)) + 
  geom_point() + 
  geom_smooth(color = "grey") + 
  geom_point(data = pop_den_comparison %>% filter(pop_density > 100000), 
             color = "red") + 
  xlim(0, 5) +
  # geom_smooth() + 
  # geom_smooth(color = "red", fill = "grey") +
  theme_minimal() +
  labs(x = "SAB area (miles)", y = "% Difference, Areal Interpolation")

pop_den_comparison %>%
  as.data.frame() %>%
  select(-geometry) %>%
  mutate(area_bin = cut(area_miles, 
                       breaks = c(unique(quantile(area_miles, 
                                           probs = seq(0, 1, by = 0.20), 
                                           na.rm = TRUE))), 
                       include.lowest = TRUE)) %>%
  group_by(area_bin) %>%
  summarize(total_utilities = n(), 
            mean_per_diff = mean(sdwis_interp_percent_diff)) 

# area <= 0.054 seems like a good breaking point between methods
###############################################################################
# Testing splitting methods: 
###############################################################################
# want to use sdwis populations for these: 
use_sdwis <- demo$census %>%
  filter(area_miles <= 0.054) %>%
  st_transform(., crs = "ESRI:102296") %>%  
  filter(!st_is_empty(.))%>%
  select(pwsid, geometry)

# basically want to use SDWIS populations but keep proportions of things 
# relatively consistent from areal interpolation - keeping census vars 
# simple for now: 
census_vars <- c(total_pop = "B01003_001",
                 white_alone = "B02001_002")

tx_census <- tidycensus::get_acs(
  geography = "tract", 
  variables = census_vars, 
  state = c("TX"), 
  year = 2020,
  geometry = TRUE
) 

tx_wide <- pivot_wider(tx_census, 
                       names_from = c("variable"), 
                       values_from = c("estimate", "moe")) %>%
  select(GEOID:estimate_white_alone) %>%
  st_transform(., crs = "ESRI:102296") %>%  
  filter(!st_is_empty(.))

# interpolating: 
test_inter <- areal::aw_interpolate(use_sdwis, tid="pwsid", 
                                    source=tx_wide, 
                                    sid="GEOID", 
                                    # weight = "sum",
                                    weight = "total",
                                    output="sf", 
                                    extensive = c("estimate_total_pop", 
                                                  "estimate_white_alone"))
                                    # intensive = "mhi_percent_uni")

# grabbing pwsid sdwis values for the filtered data: 
pwsid_sdwis <- demo$census %>%
  filter(area_miles <= 0.054) %>%
  as.data.frame() %>%
  select(-geometry) %>%
  select(pwsid, population_served_count)

# testing keeping proportions constant while using sdwis population: 
test_inter <- test_inter %>%
  mutate(proportion = estimate_white_alone/estimate_total_pop) %>%
  left_join(pwsid_sdwis) %>%
  mutate(white_alone_test = population_served_count*proportion)


###############################################################################
# Testing interpolating over non-count vars:  
###############################################################################
census_vars <- c(total_pop = "B01003_001",
                 # race and ethnicity stats: 
                 black_alone = "B02001_003", 
                 asian_alone = "B02001_005", 
                 white_alone = "B02001_002", 
                 AIAN_alone = "B02001_004", 
                 NAPI_alone = "B02001_006", 
                 other_alone = "B02001_007", 
                 mixed_alone = "B02001_008",
                 hisp_alone = "B03003_003", 
                 # MHI
                 mhi = "B19013_001", 
                 # labor force and unemployment: 
                 laborforce = "B23025_003",  # universe: pop > 16
                 laborforce_unemployed = "B23025_005", # universe: pop > 16
                 # households below poverty level: 
                 hh_total = "B17017_001",
                 hh_below_pov = "B17017_002", 
                 # age stats: 
                 ageunder_5  = "B06001_002",
                 age5_17 = "B06001_003", 
                 age18_24 = "B06001_004",
                 age25_34 = "B06001_005", 
                 age35_44 = "B06001_006", 
                 age45_54 = "B06001_007", 
                 age55_59 = "B06001_008", 
                 age60_61 = "B06001_009",
                 # language spoken at home: 
                 only_english = "B99162_002",  # universe: pop >5
                 other_lang = "B99162_003", # universe: pop >5
                 # education categories: 
                 no_school = "B15003_002", 
                 high_school = "B15003_017", 
                 bachelors = "B15003_022",
                 prof_degree = "B15003_024", 
                 # nationality: 
                 foreign = "B99051_005")

tx_census <- tidycensus::get_acs(
  geography = "tract", 
  variables = census_vars, 
  state = c("TX"), 
  year = 2020,
  geometry = TRUE
) 

tx_wide <- pivot_wider(tx_census, 
                       names_from = c("variable"), 
                       values_from = c("estimate", "moe")) %>%
  select(GEOID:estimate_other_lang)

# calculating the percent MHI for the entire universe: 
test <- tx_wide %>%
  select(GEOID, estimate_mhi) %>%
  mutate(mhi_percent_uni = estimate_mhi / sum(tx_wide$estimate_mhi, na.rm = T)) %>%
  st_transform(., crs = "ESRI:102296") %>%  
  filter(!st_is_empty(.))

# grabbing sabs:
test_sdiws <- demo$census %>%
  st_transform(., crs = "ESRI:102296") %>%  
  filter(!st_is_empty(.))%>%
  select(pwsid, geometry)

# interpolating - need to use summed weights when using the spatially 
# intensive method: 
test_inter <- areal::aw_interpolate(test_sdiws, tid="pwsid", 
                                    source=test, 
                                    sid="GEOID", 
                                    weight = "sum",
                                    # weight = "total",
                                    output="sf", 
                                    intensive = "mhi_percent_uni")

# recalculating mhi by multiplying by total universe: 
test_mhi <- test_inter %>%
  mutate(mhi = mhi_percent_uni*sum(tx_wide$estimate_mhi, na.rm = T))

# comparing mhi methods using crosswalk vs areal interpolation: 
mhi_comp <- test_mhi %>%
  as.data.frame() %>%
  select(-geometry) %>%
  left_join(keys$analysis_keys)

ggplot(mhi_comp, aes(x = mhi, y = estimate_mhi)) + 
  geom_point() + 
  geom_smooth() + 
  theme_minimal() + 
  labs(x = "MHI - Areal Interpolation Method", 
       y = "MHI - Crosswalk Method")
# sweet - pretty close 1:1 relationship 

## testing methods for calculating % households below poverty: 
census_hh <- tx_wide %>%
  select(GEOID, estimate_hh_total, estimate_hh_below_pov)%>%
  mutate(percent_hh_pov = (estimate_hh_below_pov/estimate_hh_total)*100) %>%
  st_transform(., crs = "ESRI:102296") %>%  
  filter(!st_is_empty(.))

hh_test_ext <- areal::aw_interpolate(test_sdiws, tid="pwsid", 
                                    source=census_hh, 
                                    sid="GEOID", 
                                    # weight = "sum",
                                    weight = "total",
                                    output="sf", 
                                    extensive = c("estimate_hh_total", 
                                                  "estimate_hh_below_pov"))

hh_test_ext <- hh_test_ext %>%
  mutate(percent_hh_pov = (estimate_hh_below_pov/estimate_hh_total)*100)

hh_test_int <- areal::aw_interpolate(test_sdiws, tid="pwsid", 
                                    source=census_hh, 
                                    sid="GEOID", 
                                    weight = "sum",
                                    # weight = "total",
                                    output="sf", 
                                    intensive = c("percent_hh_pov"))

hh_test_int <- hh_test_int %>%
  as.data.frame() %>%
  select(-geometry) %>% 
  rename(percent_hh_int = percent_hh_pov)

hh_test <- merge(hh_test_ext, hh_test_int)
ggplot(hh_test, aes(x = percent_hh_int, percent_hh_pov)) + 
  geom_point() + 
  # geom_point(data = (sab_census %>% filter(area_miles < 0.054)), color = "red") +
  labs(x = "Areal Interpolation - Percent to Intensive Method", 
       y = "Areal Interpolation - Extensive to Percent Method") + 
  theme_minimal() 

```


## Testing the method with the full socioeconomic dataset: 
```{r}
###############################################################################
# Let's try doing the entire thing
###############################################################################
sab <- demo$census %>%
  select(pwsid:pop_density, service_area_type_code)%>%
  st_transform(., crs = "ESRI:102296") %>%
  filter(!st_is_empty(.))

census_vars <- c(total_pop = "B01003_001",
                 # race and ethnicity stats: 
                 black_alone = "B02001_003", 
                 asian_alone = "B02001_005", 
                 white_alone = "B02001_002", 
                 AIAN_alone = "B02001_004", 
                 NAPI_alone = "B02001_006", 
                 other_alone = "B02001_007", 
                 mixed_alone = "B02001_008",
                 hisp_alone = "B03003_003", 
                 # MHI - will have to do mhi separately since it is a non-count 
                 # varibale 
                 mhi = "B19013_001",
                 # labor force and unemployment: 
                 laborforce = "B23025_003",  # universe: pop > 16
                 laborforce_unemployed = "B23025_005", # universe: pop > 16
                 # households below poverty level: 
                 hh_total = "B17017_001",
                 hh_below_pov = "B17017_002", 
                 # age stats: 
                 ageunder_5  = "B06001_002",
                 age5_17 = "B06001_003", 
                 age18_24 = "B06001_004",
                 age25_34 = "B06001_005", 
                 age35_44 = "B06001_006", 
                 age45_54 = "B06001_007", 
                 age55_59 = "B06001_008", 
                 age60_61 = "B06001_009",
                 # language spoken at home: 
                 only_english = "B99162_002",  # universe: pop >5
                 other_lang = "B99162_003", # universe: pop >5
                 # education categories: 
                 no_school = "B15003_002", 
                 high_school = "B15003_017", 
                 bachelors = "B15003_022",
                 prof_degree = "B15003_024", 
                 # nationality: 
                 foreign = "B99051_005")

tx_census <- tidycensus::get_acs(
  geography = "tract", 
  variables = census_vars, 
  # grab stats for neighboring states since some are close to the border: 
  state = c("TX", "AR", "OK", "NM", "LA"), 
  year = 2020,
  geometry = TRUE
) 

tx_wide <- pivot_wider(tx_census, 
                       names_from = c("variable"), 
                       values_from = c("estimate", "moe")) %>%
  select(GEOID:estimate_other_lang) %>%
  st_transform(., crs = "ESRI:102296")

# interpolating: 
# extensive_vars <- unique(paste0("estimate_", tx_census$variable))
tx_inter <- areal::aw_interpolate(sab, tid = "pwsid", 
                                  source = tx_wide, 
                                  sid= "GEOID", 
                                  weight = "total",
                                  output="sf", 
                                  # for some reason, function can't handle a vector
                                  extensive = c("estimate_total_pop", 
                                                "estimate_white_alone", 
                                                "estimate_black_alone", 
                                                "estimate_AIAN_alone", 
                                                "estimate_asian_alone", 
                                                "estimate_NAPI_alone", 
                                                "estimate_other_alone", 
                                                "estimate_mixed_alone", 
                                                "estimate_hisp_alone", 
                                                "estimate_foreign", 
                                                "estimate_only_english", 
                                                "estimate_other_lang",
                                                "estimate_ageunder_5", 
                                                "estimate_age5_17", 
                                                "estimate_age18_24", 
                                                "estimate_age25_34", 
                                                "estimate_age35_44", 
                                                "estimate_age45_54", 
                                                "estimate_age55_59", 
                                                "estimate_age60_61", 
                                                "estimate_no_school", 
                                                "estimate_high_school",
                                                "estimate_bachelors", 
                                                "estimate_prof_degree", 
                                                "estimate_hh_total", 
                                                "estimate_hh_below_pov", 
                                                "estimate_laborforce", 
                                                "estimate_laborforce_unemployed"))

# flag for pwsids where we're using the SDWIS method: 
tx_inter <- tx_inter %>%
  mutate(sdwis_flag = case_when(area_miles <= 0.054 ~ "SDWIS", 
                                TRUE ~ "Areal"))


# interpolating for mhi and % households below poverty- since this is spatially 
# intensive and requires summed weights. Calculating this household percentage 
# for small utilities: 
tx_wide_mhi <- tx_wide %>%
  mutate(mhi_percent_uni = estimate_mhi / sum(tx_wide$estimate_mhi, na.rm = T)) %>%
  st_transform(., crs = "ESRI:102296") %>%  
  filter(!st_is_empty(.))

mhi_inter <- areal::aw_interpolate(sab, tid = "pwsid",
                                   source = tx_wide_mhi,
                                   sid = "GEOID",
                                   weight = "sum",
                                   output ="sf",
                                   intensive = c("mhi_percent_uni"))

# recalculating mhi by multiplying by total universe: 
pwsid_mhi <- mhi_inter %>%
  mutate(estimate_mhi = mhi_percent_uni*sum(tx_wide$estimate_mhi, na.rm = T)) %>%
  as.data.frame() %>%
  select(-geometry) %>%
  select(pwsid, estimate_mhi)


# reorganizing and calculating percentages for entire dataset: 
tx_inter_clean_per <- tx_inter %>%
  select(starts_with(c("pwsid", "area_miles", "sdwis_flag",
                       "population_served_count",
                       "estimate"))) %>%
  relocate(pwsid) %>%
  # adding median household income and households below poverty: 
  left_join(pwsid_mhi) %>%
  # leaving out columns that shouldn't be divided:
  mutate_at(vars(!c("pwsid","sdwis_flag", "area_miles", 
                    "estimate_total_pop", "population_served_count", 
                    "estimate_mhi", 
                    "estimate_hh_total", "estimate_hh_below_pov",
                    "estimate_laborforce", "estimate_laborforce_unemployed")),
            ~((./estimate_total_pop)*100)) %>%
  # calculating percentages where the universe is not total population: 
  mutate(estimate_laborforce_unemployed = (estimate_laborforce_unemployed/estimate_laborforce)*100, 
         estimate_hh_below_pov = (estimate_hh_below_pov/estimate_hh_total)*100,
         estimate_poc_alone = (100 - estimate_white_alone)) %>%
  relocate(estimate_total_pop, .before = estimate_age18_24) %>%
  as.data.frame() %>%
  select(-c(geometry, area_miles, sdwis_flag, population_served_count))
colnames(tx_inter_clean_per) <- paste0(colnames(tx_inter_clean_per), "_per")

# merging this back so we have the original census numbers as well:  
sab_census <- merge(tx_inter, tx_inter_clean_per, by.x = "pwsid", 
                    by.y = "pwsid_per") %>%
  # removing potentially misleading and duplicated columns: 
  select(-c(estimate_total_pop_per, 
            estimate_hh_total_per, estimate_laborforce_per)) %>%
  rename(estimate_mhi = estimate_mhi_per)


# Fixing SABs with small areas, where the areal interpolation method is 
# less accurate: 
# multiplying SDWIS populations by percentages found through areal interpolation 
# Aiming to keep relative proportion the same for utilities that we decided should
# use SDWIS estimates
tx_sdwis_fix <- sab_census %>%
  filter(sdwis_flag == "SDWIS") %>%
  as.data.frame() %>%
  select(-c(estimate_mhi, estimate_poc_alone_per,
            estimate_hh_below_pov_per, 
            estimate_laborforce_unemployed_per, geometry)) %>%
  select("pwsid", "population_served_count", ends_with("_per")) %>%
  # leaving out columns that shouldn't be divided, and finding counts using 
  # SDWIS and the proportion created by areal interpolation:
  mutate_at(vars(estimate_age18_24_per:estimate_white_alone_per),
            ~((./100)*population_served_count)) %>% 
  # making this the new estimate total pop
  rename(estimate_total_pop = population_served_count)
names(tx_sdwis_fix) <- gsub("_per", "", names(tx_sdwis_fix))


# tidying fixed dataset to match sab_census for recombining: 
need_fix <- sab_census %>%
  filter(sdwis_flag == "SDWIS") 
tx_sdwis_fixed <- merge(need_fix, tx_sdwis_fix, by = "pwsid") %>%
  select(!ends_with(".x")) %>%
  # removing these columns, since we don't have "accurate" raw numbers, just 
  # the percentage: 
  mutate(estimate_hh_below_pov = NA, 
         estimate_hh_total = NA, 
         estimate_laborforce = NA, 
         estimate_laborforce_unemployed = NA)
names(tx_sdwis_fixed) <- gsub("\\.y$", "", names(tx_sdwis_fixed))
tx_sdwis_fixed <- tx_sdwis_fixed[ ,names(sab_census)]


# recombining: 
sab_census_areal <- sab_census %>% 
  filter(sdwis_flag == "Areal")
sab_census_final <- rbind(sab_census_areal, tx_sdwis_fixed)


# reordering columns
name_order <- demo$census %>% 
  mutate(sdwis_flag = "NA") %>%
  select(-estimate_laborforce_per)
sab_census_final_areal <- sab_census_final[ ,names(name_order)]
```


## Investigating results: 
```{r}
areal_results <- sab_census_final_areal %>%
  mutate(percent_diff = ((population_served_count - estimate_total_pop)/((population_served_count + estimate_total_pop)/2))*100)
crosswalk_results <- demo$census %>%
  mutate(percent_diff = ((population_served_count - estimate_total_pop)/((population_served_count + estimate_total_pop)/2))*100)

ggplot(areal_results, aes(x = percent_diff, 
                                   y = area_miles)) + 
  geom_point() + 
  geom_point(data = crosswalk_results, color = "red")


## where are NAs for median household income? 
sab_census_final_areal <- sab_census_final_areal %>%
  st_as_sf() %>%
  st_transform(., crs = st_crs(tx_census)) 

test_mhi <- mhi_inter %>%
  mutate(estimate_mhi = mhi_percent_uni*sum(tx_wide$estimate_mhi, 
                                            na.rm = T)) %>%
  st_as_sf() %>%
  st_transform(., crs = st_crs(tx_census))
  # filter(is.na(estimate_mhi))

mhi_pal <- colorNumeric(
  palette = viridis::mako(9),
  domain = test_mhi$estimate_mhi, 
  na.color = "black")

leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, 
                   group = "Toner Lite") %>%
  addPolygons(data = test_mhi,
              fillOpacity = 0.9,
              stroke = TRUE,
              # color = "black",
              color = ~mhi_pal(estimate_mhi),
              weight = 1,
              label = paste0("pwsid: ", test_mhi$pwsid,
                "; mhi: ", test_mhi$estimate_mhi)) %>%
  addPolygons(data = tx_wide_mhi %>% 
                st_as_sf() %>% 
                st_transform(., crs = st_crs(tx_census)),
              weight = 1,
              color = "grey") %>%
  addPolygons(data = tx_wide_mhi %>% 
                st_as_sf() %>% 
                st_transform(., crs = st_crs(tx_census)) %>% 
                filter(is.na(mhi_percent_uni)), 
              weight = 1,
              color = "red")




# let's try IDW or kriging? 
mhi <- tx_wide_mhi %>%
  select(GEOID, NAME, estimate_total_pop, estimate_mhi, mhi_percent_uni)


# converting to point data for kriging: 
# library(sp)
# library(rgeos)

# library(gstat)
# census_centroids <- st_centroid(mhi)
# lat_long <- as.data.frame(st_coordinates(census_centroids))
# census_centroids <- cbind(census_centroids, lat_long)
# 
# lzn.vgm <- variogram(estimate_mhi ~ X + Y, census_centroids, width=0.1)
# 
# lzn.fit = fit.variogram(lzn.vgm, vgm(c("Gau", "Sph", "Mat", "Exp")), fit.kappa = TRUE)
# # 
# point <- SpatialPointsDataFrame(coordinates(estimate_mhi), 
#                                 data = estimate_mhi@mhi, 
#                                 proj4string = CRS(proj4string(estimate_mhi)))
# 
# 
# k.o <- krige(Rpoint ~1, locations=air, newdata=TPU, model=m.RSPAVE.f)

# testing areal interpolation of mhi manually: 
# mhi_inter <- areal::aw_interpolate(sab, tid = "pwsid", 
#                                    source = tx_wide_mhi, 
#                                    sid = "GEOID", 
#                                    weight = "sum",
#                                    output ="sf", 
#                                    intensive = c("mhi_percent_uni"))

# 
# source_data_interp <- raster::interpolate(sab, method = "idw")
# library(gstat)
# i <- idw(mhi_percent_uni~1, sab, grd)
# 
# 
# sab %>%
#   aw_intersect(source = tx_wide_mhi, areaVar = "area") -> intersect
# 
# intersect %>%
#   aw_total(source = tx_wide_mhi, id = GEOID, areaVar = "area", 
#            totalVar = "totalArea",
#              type = "intensive", weight = "sum") -> intersect
# intersect %>%
#   aw_weight(areaVar = "area", totalVar = "totalArea", 
#             areaWeight = "areaWeight") -> intersect
# 
# intersect %>%
#   aw_calculate(value = mhi_percent_uni, 
#                areaWeight = "areaWeight") -> intersect
# 
# intersect %>%
#   aw_aggregate(target = sab, tid = pwsid, 
#                interVar = mhi_percent_uni) -> result
# 
# 
# tx_wide_test <- tx_wide_mhi%>%
#   filter(!(st_is_empty(.)))
# source_sp <- as(tx_wide_test, "Spatial")
# 
# # Define IDW model
# idw_model <- gstat::idw(mhi_percent_uni ~ 1, source_sp)
# 
# # Perform IDW interpolation on the grid
# idw_interpolated <- predict(idw_model, grid)

```


## MOE table: 
```{r}
census_crosswalk <- demo$census %>%
  as.data.frame() %>%
  select(-c(geometry, service_area_type_code)) %>%
  select(pwsid, estimate_total_pop:estimate_poc_alone_per)
names(census_crosswalk) <- paste0("crosswalk_", names(census_crosswalk))

census_areal <- sab_census_final_areal

# start of the moe table, with both methods incorporated: 
moe_table <- merge(census_areal, census_crosswalk, by.x = "pwsid", by.y = "crosswalk_pwsid")
```


## Population weighted interpolation method: 
```{r}
# loading library: 
library(tigris)
options(tigris_use_cache = TRUE)

# loading block weights: 
tx_blocks <- blocks(
  state = "TX", 
  year = 2020)

################################################################################
## Count census vars:
################################################################################
tx_wide_mini_pop <- tx_wide_mhi %>% 
  st_transform(., crs = st_crs(tx_blocks)) %>%
  select(estimate_total_pop, estimate_white_alone)

sab_pw <- sab %>% 
  st_transform(., crs = st_crs(tx_blocks)) %>%
  filter(county_served == "HARRIS")

pw_inter_pop <- interpolate_pw(
  from = tx_wide_mini_pop,
  to = sab_pw,
  to_id = "pwsid",
  extensive = TRUE, 
  weights = tx_blocks,
  weight_column = "POP20",
  crs = 32138
)

################################################################################
## Households below poverty: 
################################################################################
tx_wide_hh_pw <- tx_wide_mhi %>% 
  st_transform(., crs = st_crs(tx_blocks)) %>%
  select(estimate_hh_total, estimate_hh_below_pov)

# since we're using household data, should we use housing20 as weights? I'm 
# sure they're correlated but feel more comfortable using housing density 
# as weights when working with housing data: 
pw_inter_hh <- interpolate_pw(
  from = tx_wide_hh_pw,
  to = sab_pw,
  to_id = "pwsid",
  extensive = TRUE, 
  weights = tx_blocks,
  weight_column = "HOUSING20",
  crs = 32138
)

pwsid_hh <- pw_inter_hh %>%
  mutate(estimate_hh_below_pov_per = 100*(estimate_hh_below_pov/estimate_hh_total)) %>%
  select(pwsid, estimate_hh_below_pov_per)

################################################################################
## Median household income: 
################################################################################
tx_wide_mini_pw <- tx_wide_mhi %>% 
  st_transform(., crs = st_crs(tx_blocks)) %>%
  select(mhi_percent_uni)

# pop weighted interpolation on median household income: 
pw_interp_mhi <- interpolate_pw(
  from = tx_wide_mini_pw,
  to = sab_pw,
  to_id = "pwsid",
  extensive = FALSE, 
  weights = tx_blocks,
  weight_column = "POP20",
  crs = 32138
)

# transforming percentage of universe to actual mhi: 
pwsid_mhi <- pw_interp_mhi %>%
  mutate(estimate_mhi = mhi_percent_uni*sum(tx_wide_mhi$estimate_mhi,
                                            na.rm = T)) %>%
  st_as_sf() %>%
  st_transform(., crs = st_crs(tx_blocks))

################################################################################
## Bringing everything back together: 
################################################################################
pwsid_mhi_df <- pwsid_mhi %>%
  as.data.frame() %>%
  select(-geometry)

pwsid_hh_df <- pwsid_hh %>%
  as.data.frame() %>%
  select(-geometry)

# all census data: 
all_census <- pw_inter_pop %>%
  left_join(pwsid_mhi_df) %>%
  left_join(pwsid_hh_df)

# grabbing NAs for areal interpolation: 
na_pw <- all_census %>%
  filter(is.na(estimate_total_pop))

################################################################################
## Fixing NAs using areal weighted interpolation & SDWIS
################################################################################
tx_wide_pop_hh_aw <- tx_wide_mhi %>% 
  st_transform(., crs = "ESRI:102296") %>%
  # combining popualtion and hh calculations since aw_interpolate is similar: 
  select(GEOID, estimate_total_pop, estimate_white_alone, 
         estimate_hh_total, estimate_hh_below_pov)

sab_pw_na <- sab %>% 
  filter(county_served == "HARRIS") %>%
  st_transform(., crs = "ESRI:102296") %>%
  filter(pwsid %in% na_pw$pwsid)

# aw interpolation of population: 
aw_inter_pop_hh <- areal::aw_interpolate(sab_pw_na, tid = "pwsid", 
                                         source = tx_wide_pop_hh_aw, 
                                         sid= "GEOID", 
                                         weight = "total",
                                         output="sf", 
                                         extensive = c("estimate_total_pop", 
                                                       "estimate_white_alone", 
                                                       "estimate_hh_total", 
                                                       "estimate_hh_below_pov"))
# estimating new values using SDWIS: 
aw_inter_pop_hh_pwsid <- aw_inter_pop_hh %>%
  mutate(estimate_white_alone_per = 100*(estimate_white_alone/estimate_total_pop), 
         estimate_white_alone = (estimate_white_alone_per/100)*population_served_count, 
         estimate_total_pop = population_served_count, 
         estimate_hh_below_pov_per = 100*(estimate_hh_below_pov/estimate_hh_total))


# aw interpolation of mhi: 
tx_wide_mhi_aw <- tx_wide_mhi %>% 
  st_transform(., crs = "ESRI:102296") %>%
  select(GEOID, estimate_mhi, mhi_percent_uni)

aw_inter_mhi <- areal::aw_interpolate(sab_pw_na, tid = "pwsid", 
                                      source = tx_wide_mhi_aw, 
                                      sid= "GEOID", 
                                      weight = "sum",
                                      output="sf", 
                                      intensive = c("mhi_percent_uni"))

# putting back in context with universe: 
aw_inter_pwsid_mhi <- aw_inter_mhi %>%
  mutate(estimate_mhi = mhi_percent_uni*sum(tx_wide_mhi_aw$estimate_mhi, 
                                            na.rm = T)) %>%
  as.data.frame() %>%
  select(-geometry) %>%
  select(pwsid, mhi_percent_uni, estimate_mhi)


# recombining with NA datastet: 
aw_inter_fill <- aw_inter_pop_hh_pwsid %>%
  left_join(aw_inter_pwsid_mhi)

################################################################################
## Recombining with overall dataset: 
################################################################################
aw_inter_fill_mini <- aw_inter_fill %>%
  select(pwsid, estimate_total_pop, estimate_white_alone, 
         mhi_percent_uni, estimate_mhi, estimate_hh_below_pov_per) %>%
  mutate(interpolation_method = "areal_sdwis") %>%
    st_transform(., crs = "ESRI:102296") 

pw_inter_complete <- all_census %>%
  filter(!(is.na(estimate_total_pop))) %>%
  mutate(interpolation_method = "pop_weighted") %>%
  st_transform(., crs = "ESRI:102296") 

complete_data <- rbind(aw_inter_fill_mini, pw_inter_complete)
# there are 8 entries that have 0 total pop 

################################################################################
## Investigating output: 
################################################################################
complete_data_sf <- complete_data %>%
  st_as_sf(.) %>%
  st_transform('+proj=longlat +datum=WGS84') %>%
  filter(!st_is_empty(.))

tx_blocks_harris_nopop <- tx_blocks %>%
  filter(COUNTYFP20 == "201") %>%
  # filter(POP20 > 0) %>%
  st_transform('+proj=longlat +datum=WGS84')

mhi_pal <- colorNumeric(
  palette = viridis::mako(9),
  domain = complete_data_sf$estimate_mhi,
  na.color = "red")

leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels,
                   group = "Toner Lite") %>%
    addPolygons(data = tx_blocks_harris_nopop, 
              color = "blue", 
              weight = 1, 
              label = paste0("pop: ", tx_blocks_harris_nopop$POP20)) %>%
  addPolygons(data = complete_data_sf,
              fillOpacity = 0.3,
              stroke = TRUE,
              # color = "black",
              color = ~mhi_pal(estimate_mhi),
              weight = 1,
              label = paste0("pwsid: ", complete_data_sf$pwsid,
                             "; mhi: ", round(complete_data_sf$estimate_mhi, 2), 
                             "; pop: ", round(complete_data_sf$estimate_total_pop, 2)))



areal <- complete_data_sf %>%
  filter(interpolation_method == "areal_sdwis")
pw <- complete_data_sf %>%
  filter(interpolation_method == "pop_weighted")

leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels,
                   group = "Toner Lite") %>%
  addPolygons(data = pw,
              fillOpacity = 0.6,
              stroke = TRUE,
              color = "black",
              # color = ~mhi_pal(estimate_mhi),
              weight = 1,
              label = paste0("pwsid: ", pw$pwsid,
                             "; mhi: ", round(pw$estimate_mhi, 2), 
                             "; pop: ", round(pw$estimate_total_pop, 2))) %>%
  addPolygons(data = areal,
              fillOpacity = 0.6,
              stroke = TRUE,
              color = "red",
              # color = ~mhi_pal(estimate_mhi),
              weight = 1,
              label = paste0("pwsid: ", areal$pwsid,
                             "; mhi: ", round(areal$estimate_mhi, 2), 
                             "; pop: ", round(areal$estimate_total_pop, 2))) %>%
  addPolygons(data = tx_blocks_harris_nopop, 
              color = "blue", 
              weight = 1, 
              label = paste0("pop: ", tx_blocks_harris_nopop$POP20))

# still some NAs, but this might just be pwsids where census pop == 0, 
# or MHI was not reported in the 2020 census.

# taking a closer look, some of these SABs overlap with universities, airports, 
# or interstates 
```


## Final crosswalk method: using a tiered approach, where: 
tier 1 = pw_interpolation, 
tier 2 = crosswalk the NAs from pw_interpolation 
tier 3 = fell out of both methods
```{r}
################################################################################
## Data prep: 
################################################################################
# grabbing SABs: 
sab <- demo$census %>%
  select(pwsid:pop_density, service_area_type_code)%>%
  st_transform(., crs = "EPSG:32138") %>%
  filter(!st_is_empty(.))

# grabbing census data: 
census_vars <- c(total_pop = "B01003_001",
                 # race and ethnicity stats: 
                 black_alone = "B02001_003", 
                 asian_alone = "B02001_005", 
                 white_alone = "B02001_002", 
                 AIAN_alone = "B02001_004", 
                 NAPI_alone = "B02001_006", 
                 other_alone = "B02001_007", 
                 mixed_alone = "B02001_008",
                 hisp_alone = "B03003_003", 
                 # MHI - will have to do mhi separately since it is a non-count 
                 # varibale 
                 mhi = "B19013_001",
                 # labor force and unemployment: 
                 laborforce = "B23025_003",  # universe: pop > 16
                 laborforce_unemployed = "B23025_005", # universe: pop > 16
                 # households below poverty level: 
                 hh_total = "B17017_001",
                 hh_below_pov = "B17017_002", 
                 # age stats: 
                 ageunder_5  = "B06001_002",
                 age5_17 = "B06001_003", 
                 age18_24 = "B06001_004",
                 age25_34 = "B06001_005", 
                 age35_44 = "B06001_006", 
                 age45_54 = "B06001_007", 
                 age55_59 = "B06001_008", 
                 age60_61 = "B06001_009",
                 # language spoken at home: 
                 only_english = "B99162_002",  # universe: pop >5
                 other_lang = "B99162_003", # universe: pop >5
                 # education categories: 
                 no_school = "B15003_002", 
                 high_school = "B15003_017", 
                 bachelors = "B15003_022",
                 prof_degree = "B15003_024", 
                 # nationality: 
                 foreign = "B99051_005")

tx_census <- tidycensus::get_acs(
  geography = "tract", 
  variables = census_vars, 
  # grab stats for neighboring states since some are close to the border: 
  state = c("TX", "AR", "OK", "NM", "LA"), 
  year = 2020,
  geometry = TRUE
) 

tx_wide <- pivot_wider(tx_census, 
                       names_from = c("variable"), 
                       values_from = c("estimate", "moe")) %>%
  select(GEOID:estimate_other_lang) %>%
  st_transform(., crs = "EPSG:32138")


# tract crosswalk for tier 2: 
tract_crosswalk <- aws.s3::s3read_using(read.csv, 
                                         object = "s3://tech-team-data/pws_crosswalk/pws_census_tract_weighted_crosswalk.csv") %>%
  select(-X) %>%
  filter(pwsid %in% pwsids) %>%
  # if the geoid is missing prefix 0, add it back in
  mutate(tract_geoid = as.character(tract_geoid),
         tract_geoid = case_when(
           str_length(tract_geoid) == 10 ~ paste0(0, tract_geoid),
           TRUE ~ tract_geoid
         )) %>%
  # there are 7 tract geoids in the crosswalk are NAs - assuming these are errors? 
  filter(!(is.na(tract_geoid)))


################################################################################
## Tier 1: Population-weighted interpolation: 
################################################################################
# loading block weights: 
tx_blocks <- tigris::blocks(
  state = "TX", 
  year = 2020)

# pw interpolation on count vars where the universe is total population: 
tx_wide_pop <- tx_wide %>% 
  select(estimate_total_pop, estimate_white_alone)

sab_pw <- sab %>% 
  st_transform(., crs = st_crs(tx_blocks)) %>%
  filter(county_served == "HARRIS")

pw_inter_pop <- interpolate_pw(
  from = tx_wide_pop,
  to = sab_pw,
  to_id = "pwsid",
  extensive = TRUE, 
  weights = tx_blocks,
  weight_column = "POP20",
  crs = 32138)

## Households below poverty: 
tx_wide_hh <- tx_wide %>% 
  select(estimate_hh_total, estimate_hh_below_pov)

# since we're using household data, should we use housing20 as weights? I'm 
# sure they're correlated but feel more comfortable using housing density 
# as weights when working with housing data: 
pw_inter_hh <- interpolate_pw(
  from = tx_wide_hh,
  to = sab_pw,
  to_id = "pwsid",
  extensive = TRUE, 
  weights = tx_blocks,
  weight_column = "HOUSING20",
  crs = 32138)

pwsid_hh <- pw_inter_hh %>%
  mutate(estimate_hh_below_pov_per = 100*(estimate_hh_below_pov/estimate_hh_total)) 
  # select(pwsid, estimate_hh_below_pov_per)


## Median household income: 
tx_wide_mhi <- tx_wide %>% 
  select(mhi_percent_uni)

# pop weighted interpolation on median household income: 
pw_interp_mhi <- interpolate_pw(
  from = tx_wide_mhi,
  to = sab_pw,
  to_id = "pwsid",
  extensive = FALSE, 
  weights = tx_blocks,
  weight_column = "POP20",
  crs = 32138
)

# transforming percentage of universe to actual mhi: 
pwsid_mhi <- pw_interp_mhi %>%
  mutate(estimate_mhi = mhi_percent_uni*sum(tx_wide_mhi$estimate_mhi,
                                            na.rm = T)) %>%
  st_as_sf() %>%
  st_transform(., crs = st_crs(tx_blocks))


## Bringing everything back together: 
pwsid_mhi_df <- pwsid_mhi %>%
  as.data.frame() %>%
  select(-geometry)

pwsid_hh_df <- pwsid_hh %>%
  as.data.frame() %>%
  select(-geometry)

# all census data: 
all_census <- pw_inter_pop %>%
  left_join(pwsid_mhi_df) %>%
  left_join(pwsid_hh_df)

# grabbing NAs for tier 2: 
pw <- all_census %>%
  filter(!is.na(estimate_total_pop)) %>%
  mutate(tier_crosswalk = "tier_1")


################################################################################
## Tier 2: crosswalking 
################################################################################
# locating the pwsids that fell out of pw interpolation: 
xwalk <- all_census %>%
  filter(is.na(estimate_total_pop)) 

# df prep: 
pwsid_cross <- tract_crosswalk %>%
  filter(pwsid %in% xwalk$pwsid) 
 
tx_wide_cross <- tx_wide %>%
  select(GEOID, estimate_total_pop, estimate_white_alone,
         estimate_mhi, estimate_hh_total, estimate_hh_below_pov)


# merging tx census stats with crosswalk: 
pwsid_xwalk <- merge(tx_wide_cross, pwsid_cross, 
                      by.x = "GEOID", by.y = "tract_geoid", all.y = T)

# multiplying census stats by tract weights:
pwsid_weight_xwalk <- pwsid_xwalk %>% 
  mutate(across(estimate_total_pop:estimate_white_alone, ~.*tract_parcel_weight)) %>%
  mutate(across(estimate_hh_total:estimate_hh_below_pov, ~.*tract_parcel_weight))

# sum across pwsid and estimate mhi using a weighted mean: 
pwsid_weighted_xwalk <- pwsid_weight_xwalk %>%
  group_by(pwsid) %>% 
  summarize(across(estimate_total_pop:estimate_white_alone, ~round(sum(.), 2)), 
            estimate_mhi = weighted.mean(estimate_mhi, tract_parcel_weight, na.rm = TRUE), 
            across(estimate_hh_total:estimate_hh_below_pov, ~round(sum(.), 2))) 

# calculating percentage: 
pwsid_weighted_per <- pwsid_weighted_xwalk %>%
  as.data.frame() %>%
  select(-geometry) %>%
  select(starts_with(c("estimate", "pwsid"))) %>%
  mutate_at(vars(!c("estimate_total_pop", "estimate_mhi", "pwsid")), 
            ~((./estimate_total_pop)*100)) %>%
  relocate("pwsid") 
  # mutate(estimate_poc_alone = (100 - estimate_white_alone)) 
colnames(pwsid_weighted_per) <- paste0(colnames(pwsid_weighted_per), "_per")

# merging percentages back with original counts: 
pwsid_xwalked <- merge(pwsid_weighted_xwalk, pwsid_weighted_per,
                       by.x = "pwsid", by.y = "pwsid_per") %>%
  select(-c("estimate_total_pop_per", "estimate_mhi_per")) %>%
  select(-c("estimate_hh_total_per")) %>%
  # recalculating % households in poverty and % labor force unemployed
  mutate(estimate_hh_below_pov_per = (estimate_hh_below_pov/estimate_hh_total*100))
         # estimate_laborforce_unemployed_per = (estimate_laborforce_unemployed/estimate_laborforce)*100)


# want to cap max total pop to those reported by SDWIS: 
sdwis_pop <- sab %>%
  as.data.frame() %>%
  select(-geometry) %>%
  select(pwsid, population_served_count)

sdwis_xwalk <- pwsid_xwalked %>%
  left_join(sdwis_pop) %>%
  relocate(population_served_count, .before = estimate_total_pop) 
  
# capping max pop at SDWIS values: 
sdwis_pop <- sdwis_xwalk %>%
  filter(estimate_total_pop > population_served_count) %>%
  mutate(estimate_white_alone = (estimate_white_alone_per/100)*population_served_count, 
         estimate_total_pop = population_served_count, 
         # we can no longer estimate number of households using this method 
         estimate_hh_total = NA, 
         tier_crosswalk = "tier_2_sdiwspop")

# recombining with other pwsids where xwalk < SDWIS: 
xwalk_pop <-  sdwis_xwalk %>%
  filter(estimate_total_pop < population_served_count) %>%
  mutate(tier_crosswalk = "tier_2_xwalkpop")

final_xwalk <- rbind(sdwis_pop, xwalk_pop) %>%
  select(-population_served_count) %>%
  mutate(mhi_percent_uni = NA)

################################################################################
## Combining tier 1 and 2 methods & tier 3 designation: 
################################################################################
final_xwalk <- final_xwalk[, names(pw)]
final_pw_xwalk <- rbind(pw, final_xwalk)

# why are we missing a few??
# missing <- sab %>% 
#   filter(county_served == "HARRIS") %>%
#   filter(!(pwsid %in% final_pw_xwalk$pwsid))
# # they're all missing from the crosswalk :-(
# merge(pwsid_cross, missing, by = "pwsid")
# merge(as.data.frame(pw), missing, by = "pwsid")

# adding these back in, but as tier 3: 
missing_df <- missing %>%
  select(pwsid) %>%
  mutate(estimate_total_pop = NA, 
         estimate_white_alone = NA, 
         mhi_percent_uni = NA, 
         estimate_mhi = NA, 
         estimate_hh_total = NA, 
         estimate_hh_below_pov = NA, 
         estimate_hh_below_pov_per = NA,
         tier_crosswalk = "tier_3")
missing_df <- missing_df[, names(final_pw_xwalk)]

complete_crosswalk <- rbind(final_pw_xwalk, missing_df)
```


