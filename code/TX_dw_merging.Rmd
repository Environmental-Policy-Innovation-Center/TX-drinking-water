---
title: "TX Drinking Water Data Merging"
author: "EmmaLi Tsai"
date: "2024-02-15"
output: html_document
---

## Loading packages: 
```{r}
library(tidyverse)
library(leaflet)
library(sf)
library(aws.s3)
```

## Loading lists of data:  
```{r}
# reading demographic, environmental (gw and sw), water delivery system (wds)
# and financial lists generated in TX_dw_collating: 
demo <- aws.s3::s3read_using(readRDS, 
                            object = "s3://tech-team-data/state-drinking-water/TX/clean/TX_demographic_list.RData")
enviro_sw <- aws.s3::s3read_using(readRDS, 
                            object = "s3://tech-team-data/state-drinking-water/TX/clean/TX_enviro_surface_list.RData")
enviro_gw <- aws.s3::s3read_using(readRDS, 
                            object = "s3://tech-team-data/state-drinking-water/TX/clean/TX_enviro_ground_list.RData")
wds <- aws.s3::s3read_using(readRDS, 
                            object = "s3://tech-team-data/state-drinking-water/TX/clean/TX_water_delivery_list.RData")
fin <- aws.s3::s3read_using(readRDS, 
                            object = "s3://tech-team-data/state-drinking-water/TX/clean/TX_financial_list.RData")

# Also grabbing census geographies for data merging: 
census_vars <- c(total_pop = "B01003_001")
census <- tidycensus::get_acs(
  geography = "tract", 
  variables = census_vars, 
  state = "TX", 
  year = 2021,
  geometry = TRUE
)

# adding counties: 
census_tidy <- census
counties <- unlist(strsplit(census_tidy$NAME, split = ","))
census_tidy$counties <- trimws(counties[grepl("County", counties)])
```
 
## East TX counties
```{r}
# reading counties in east TX from a webscrape: 
east_tx <- read.csv("./data/raw/east_TX_counties.csv") %>%
  select(-X)

# grabbing census geographies: 
east_tx_geom <- census_tidy %>%
  filter(counties %in% paste0(east_tx$county_name, " County")) %>%
  group_by(counties) %>%
  summarize()

# grabbing the larger geography of TX
tx_geom <- census_tidy %>%
  summarize()

leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = tx_geom, 
              color = "grey", 
              weight = 1) %>%
  addPolygons(data = east_tx_geom,
              opacity = 9,
              color = "#333c6bff",
              weight = 1)
```

## Merging: surface water (reservoirs, rivers, basins) to pwsids:
```{r}
# merging impaired water bodies with basin information: 
basins <- enviro_sw$major_river_basins %>% 
  left_join(., enviro_sw$impaired_basins, by = "basin_num") %>%
  rename(basin_name_short = basin_name.x, 
         basin_name_long = basin_name.y) %>%
  select(!c("id", "label_no"))

# st_intersection with reservoir boundaries to identify which reservoirs 
# are in what basin: 
res <- enviro_sw$reservoirs %>%
  # dropping z coordinates: 
  st_zm(., drop = TRUE) %>%
  st_as_sf(.) %>%
  st_transform(., crs = st_crs(basins)) 
# switch off spherical geometry 
sf_use_s2(FALSE)
res_basin <- st_intersection(res, basins)

# st_intersection with rivers to identify which basin they fall under: 
rivers <- enviro_sw$rivers %>%
  mutate(name = toupper(name)) %>%
  rename(river_name = name)
riv_basin <- st_intersection(rivers, basins) %>%
  select(river_name:geometry) %>%
  select(-shape_len) %>%
  rename(res_name = river_name) %>%
  mutate(type = "River", 
         status = "Existing") %>%
  unique()

# combining rivers and reservoirs: 
riv_res_basin <- rbind(riv_basin, res_basin)

# matching reservoir, basins, and river with surface water intakes: 
sw <- enviro_sw$surface_water_intakes %>%
  select(-objectid) %>%
  rename()

sw_basins <- merge(riv_res_basin, sw, by.x = "res_name", by.y = "waterbody",
                   all = TRUE) %>%
  # removing reservoirs that are not a water supply 
  filter(type == "Water Supply" | is.na(type) | type == "River")

# converting sw points to sf object: 
points_sf <- sw_basins %>%
  as.data.frame() %>%
  select(-geometry) %>%
  filter(!(is.na(lat_dd)))  %>%
  st_as_sf(., coords = c("long_dd", "lat_dd"), 
           crs = st_crs(res_basin)) 

# grabbing entries that are missing from the original merge and will require 
# matching using st_intersection:
no_match <- sw_basins %>%
  filter(is.na(type)) 

# intersection with a 0.01dd buffer to find nearby water bodies that likely 
# match to the sw intake: 
missing_sw <- points_sf %>%
  filter(res_name %in% no_match$res_name) %>%
  st_buffer(., dist = 0.01)

sw_resbasin <- st_intersection(missing_sw, riv_res_basin) 
sw_resbasin_tidy <- sw_resbasin %>%
  select(c("res_name", pwsid:geometry)) 

# join back to sw_basins - creating a new column to keep track of those 
# that were merged via intersection: 
sw_basins$alt_res_name <- "NA"

sw_resbasin_tidy <- sw_resbasin_tidy %>%
  relocate(basin_num.1:status.1) %>%
  relocate(res_name) %>%
  relocate(res_name.1, .after = geometry)

# adding lat/long coords back and aligning columns & names: 
sw_resbasin_tidy <- sw_basins %>% 
  select(c("pwsid", "wtrsrc", "lat_dd", "long_dd")) %>%
  as.data.frame() %>%
  right_join(., sw_resbasin_tidy, by = c("pwsid", "wtrsrc")) %>%
  select(-geometry.x) %>%
  relocate(pwsid, .after = status.1) %>%
  relocate(wtrsrc, .after = sys_name) %>%
  relocate(c("lat_dd", "long_dd"), .after = opstat) %>%
  unique()

names(sw_resbasin_tidy) <- names(sw_basins)

# grabbing completely non-matching surface water intakes to rbind to 
# ones that were intersected
comp_missing <- no_match %>%
  filter(!(res_name %in% sw_resbasin_tidy$res_name)) %>%
  mutate(alt_res_name = "NA")

all_intersected <- rbind(sw_resbasin_tidy, comp_missing)

# filtering sw_basins to remove the entries that were matched via intersection:  
sw_basins_no_missing <- sw_basins %>%
  filter(!is.na(type))

# replacing intersected matches: 
all_sw_intakes <- rbind(all_intersected, sw_basins_no_missing) %>%
  mutate(alt_res_name = case_when(
    alt_res_name == "NA" ~ res_name, 
    TRUE ~ alt_res_name
  ))

# locating intakes that didn't match to a waterbody and adding basin: 
no_basins <- all_sw_intakes %>%
  filter(is.na(basin_name_short)) %>%
  st_as_sf(., coords = c("long_dd", "lat_dd"), 
           crs = st_crs(res_basin)) %>%
  select(-c(basin_num:status)) %>%
  mutate(alt_res_name = paste0(alt_res_name, "- no matching waterbody"))
# matching intakes that didn't match with a water body to a basin: 
no_basins_filled <- st_intersection(no_basins, basins) 

# recombining with overall data frame: 
no_basins_filled_df <- no_basins_filled %>%
  as.data.frame() %>%
  select(res_name, pwsid, wtrsrc, alt_res_name:pct_impaired)

all_sw_intakes_filled <- all_sw_intakes %>%
  filter(is.na(basin_name_short)) %>%
  select(!(basin_num:pct_impaired)) %>%
  select(!c("alt_res_name")) %>%
  left_join(no_basins_filled_df, by = c("res_name", "pwsid", "wtrsrc"))

all_sw_intakes_final <- rbind(all_sw_intakes_filled, all_sw_intakes %>%
                               filter(!is.na(basin_name_short)))

# saving: 
st_write(all_sw_intakes_final, "./data/clean/pwsid_swaterbodies.geojson")
# writing to aws: 
put_object(
  file = "./data/clean/pwsid_swaterbodies.geojson",
  object = "/state-drinking-water/TX/clean/pwsid_swaterbodies.geojson",
  bucket = "tech-team-data"
)

all_sw_intakes <- st_read("./data/clean/pwsid_swaterbodies.geojson")

# converting to points for plotting to see where there are still intakes 
# missing water bodies: 
sw_points_sf <- all_sw_intakes_final %>%
  as.data.frame() %>%
  select(-geometry) %>%
  filter(!(is.na(lat_dd))) %>%
  st_as_sf(., coords = c("long_dd", "lat_dd"), 
           crs = st_crs(res_basin)) 

wtrbdy_pal <- colorFactor(
  palette = viridis::plasma(23),
  domain = basins$baisn_name_short)

leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = basins,
              opacity = 9,
              color = ~wtrbdy_pal(basin_name_short),
              weight = 1,
              label = paste0("basin: ", basins$basin_name_short, "; % impaired: ", round(basins$pct_impaired, 2))) %>%
  addLegend("bottomright",
            pal = wtrbdy_pal,
            values = basins$basin_name_short,
            title = "Basin",
            opacity = 1) %>%
  addPolygons(data = res_basin,
              opacity = 9,
              color = ~wtrbdy_pal(basin_name_short),
              weight = 1,
              label = paste0("reservoir: ", res_basin$res_name, "; basin: ",
                             res_basin$basin_name_short)) %>%
  addCircleMarkers(data = sw_points_sf, 
                   fill = ~wtrbdy_pal(basin_name_short), 
                   color = ~wtrbdy_pal(basin_name_short), 
                   weight = 3, 
                   opacity = 9, 
                   radius = 3, 
                   label = paste0("pwsid: ", sw_points_sf$pwsid, "; waterbody: ", 
                                  sw_points_sf$res_name, 
                                  "; basin name: ", 
                                  sw_points_sf$basin_name_short)) %>%
  addPolylines(data = riv_basin,
               opacity = 9,
               color = ~wtrbdy_pal(basin_name_short),
               weight = 2,
               label = paste0("river: ", riv_basin$res_name))
```

## Merging: groundwater (aquifers, wells) to counties:
```{r}
# loading in minor and major aquifer boundaries: 
minor_aquifers <- enviro_gw$minor_aquifers %>%
  st_transform(., crs = st_crs(basins))

# toubleshooting blaine with invalid boundaries: 
# blaine <- minor_aquifers %>%
#   filter(aqu_name == "BLAINE")
# st_write(blaine, "./data/raw/blaine.geojson")

major_aquifers <- enviro_gw$major_aquifers %>%
  st_transform(., crs = st_crs(basins))

# loading in well locations: 
well_twdb <- enviro_gw$well_locations %>%
  st_as_sf(.,crs = st_crs(basins)) %>%
  filter(!(primary_wat %in% c("Unused", "Plugged or Destroyed"))) %>%
  st_transform(., crs = st_crs(basins)) %>%
  janitor::clean_names()

# plotting to investigate overlap between the minor and major aquifers: 
aq_pal <- colorFactor(
  palette = viridis::plasma(22),
  domain = minor_aquifers$aqu_name)

maj_aq_pal <- colorFactor(
  palette = viridis::mako(9),
  domain = major_aquifers$aq_name)

leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = major_aquifers,
              opacity = 9,
              color = ~maj_aq_pal(aq_name),
              weight = 1,
              label = paste0("major aq: ", major_aquifers$aq_name)) %>%
  addPolygons(data = minor_aquifers,
              opacity = 9,
              color = ~aq_pal(aqu_name),
              weight = 1,
              label = paste0("minor aq: ", minor_aquifers$aqu_name)) %>%
  addLegend("bottomright",
            pal = aq_pal,
            values = minor_aquifers$aqu_name,
            title = "Minor Aquifers",
            opacity = 1) %>%
  addLegend("bottomright",
            pal = maj_aq_pal,
            values = major_aquifers$aq_name,
            title = "Major Aquifers",
            opacity = 1) 

# tying well dataset and prepping for migration to QGIS for spatial functions: 
well_locations_counties <- well_twdb 
# st_write("./data/raw/well_locations_counties.geojson")
well_locations_counties <- st_read("./data/raw/well_locations_counties.geojson") %>%
  janitor::clean_names() %>%
  # focusing on JUST wells where the primary use is public supply 
  filter(primary_wat == "Public Supply")

# NEXT STEPS DONE IN QGIS: (working on a macro to automate this)
# - load in well_locations_counties that was saved above & filter data for 
#   "PrimaryWat" LIKE 'Public Supply'
# - load major & minor aquifer boundaries, which both have overlapping polygons
#     - NOTE: make sure the CRS is the same (currently using ESPG:4326) - you'll 
#       have to change it for minor aquifers. 
#     - NOTE: for Blaine (minor aquifer), the boundaries are invalid. 
#       When splitting, you'll have to go to advanced -> algorithm settings -> skip when invalid.
# - use the "split vector layer" tool to split the major and minor aquifers by 
#   aquifer name 
# - run intersections of the well_locations_counties on EACH aquifer boundary 
#   (both major and minor)
# - to troubleshoot issues with the Blair aquifer, go to the minor aquifer 
#   attribute table, select the "BLAIR" aqu_name entries, extract the selected 
#   feature layers, and run the intersection like you would normally. 
# - select all minor aquifer points that were created after intersecting and merge 
#   using the "merge vector layers" tool. Save it as a geojson.  
# - select all major aquifer points that were created after intersecting and merge
#   using the "merge vector layers" tool. Save it as a geojson.   
# - continue with the code below, resolving file paths as needed: 

wells_major <- st_read("./data/raw/QGIS_Export/all_major_aquifer_wells.geojson")%>%
  janitor::clean_names() %>%
  select(-c("path", "aquifer", "perimeter")) %>%
  mutate(aquifer_type = "major") %>%
  rename(aquifer_area = area, 
         aquifer_name = aq_name) %>%
  relocate(aquifer_area, .after = aquifer_name) %>%
  st_transform(., crs = st_crs(basins))

wells_minor <- st_read("./data/raw/QGIS_Export/all_minor_aquifer_wells.geojson") %>%
  janitor::clean_names() %>%
  select(-c("path", "aquifer", "minor_area")) %>%
  mutate(aquifer_type = "minor") %>%
  rename(aquifer_area = area_aq, 
         aquifer_name = aqu_name) %>%
  st_transform(., crs = st_crs(basins))

# combining ALL intersected wells: 
all_well_data <- rbind(wells_major, wells_minor)
all_well_data <- all_well_data %>%
  mutate(aquifer_type_code = paste0(aquifer_name, "-", aquifer_type))
  
# grabbing all intersecting aquifers for each unique well number: 
grouped <- split(all_well_data$aquifer_type_code, all_well_data$state_well_n)
unique_items <- lapply(grouped, unique)
# what the maximum number of aquifers a well intersects with:(5?!)
max(lengths(unique_items)) 
# transforming to data frame
well_aquifers <- plyr::ldply(unique_items, rbind)
names(well_aquifers) <- c("state_well_n", "aquifer_one", "aquifer_two", 
                          "aquifer_three", "aquifer_four", "aquifer_five")
# there were 279 wells that didn't intersect with a known aquifer 
well_final <- merge(well_locations_counties, well_aquifers, all.x = TRUE) 

st_write(well_final, "./data/clean/well_county_aquifers.geojson")
# writing to aws: 
put_object(
  file = "./data/clean/well_county_aquifers.geojson",
  object = "/state-drinking-water/TX/clean/well_county_aquifers.geojson",
  bucket = "tech-team-data"
)
well_final <- st_read("./data/clean/well_county_aquifers.geojson")

# plotting wells points and aquifers together:  
well_pal <- colorFactor(
  palette = viridis::mako(20),
  domain = well_final$aquifer_one)

maj_aq_pal <- colorFactor(
  palette = viridis::mako(9),
  domain = major_aquifers$aq_name)

leaflet() %>%
  addProviderTiles(providers$CartoDB.VoyagerNoLabels, group = "Toner Lite") %>%
  addPolygons(data = major_aquifers,
              opacity = 9,
              color = ~maj_aq_pal(aq_name),
              weight = 1,
              label = paste0("major aq: ", major_aquifers$aq_name)) %>%
  addPolygons(data = minor_aquifers,
              opacity = 9,
              color = ~aq_pal(aqu_name),
              weight = 1,
              label = paste0("minor aq: ", minor_aquifers$aqu_name)) %>%
  addLegend("bottomright",
            pal = aq_pal,
            values = minor_aquifers$aqu_name,
            title = "Minor Aquifers",
            opacity = 1) %>%
  addLegend("bottomright",
            pal = maj_aq_pal,
            values = major_aquifers$aq_name,
            title = "Major Aquifers",
            opacity = 1) %>%
  addCircleMarkers(data = well_final,
                   opacity = 9,
                   radius = 0.2,
                   color = ~well_pal(aquifer_one),
                   weight = 1,
                   label = paste0("well #:",
                                  well_final$state_well_n,
                                  "; county: ",
                                  well_final$county_name,
                                  "; aquifer one: ",
                                  well_final$aquifer_one,
                                  "; aquifer two: ",
                                  well_final$aquifer_two,
                                  "; aquifer three: ",
                                  well_final$aquifer_three,
                                  "; aquifer four: ",
                                  well_final$aquifer_four,
                                  "; aquifer five: ",
                                  well_final$aquifer_five))
```

## Merging: demographics

## Merging: finacial 

## Merging: water delivery system
```{r}
head(demo)
head(fin)
head(wds)
```

## Merging keys: 
```{r}
# pwsid, waterbody name, and basin name: 
pwsid_sw_merge <- all_sw_intakes_final %>%
  as.data.frame() %>%
  select(pwsid, sys_name, basin_name_short, res_name, alt_res_name) %>%
  unique() %>%
  # filtering NAs, from when a waterbody exists but does not supply water 
  # to a public water system: 
  filter(!is.na(pwsid))
# 350 pwsids

# well number, county, and aquifers: 
well_gw_merge <- well_final %>%
  as.data.frame() %>%
  select(state_well_n, county_name, aquifer_one:aquifer_five) %>%
  unique()
# 12996 wells
```


